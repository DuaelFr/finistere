<?php
/**
 * Synchronisation class
 * Synchronisation with Tourinsoft
 *  
 * 
 * @author    Fabien CLEMENT - fabien.clement@g-nova.fr
 * @copyright {copyright}
 * @package   {package}
 */
class Synchronisation {

	static $soap;
	static $date;
	static $flux;
	static $vocabs;
	static $vocab;
	static $termCorresp;
	static $start;
	static $retreive_sync;
	static $cache;
	static $done;
	static $onprogress;

	public function __construct($url =  "") {
		
		if(empty($url)){
			$url = variable_get('flux_url', "http://cdt29.tourinsoft.com/soft/RechercheDynamique/Syndication/controle/syndication2.asmx");
		}
		$this->soap = new nusoap_client($url.'?WSDL','WSDL');
		
  }
  
  /**
   *	Initialise variables
   */
  public function init(){
  		$cache = variable_get("flux_sync_data_cache", "");
  		
		$this->cache = new stdClass();
		$this->done = new stdClass();
		$this->onprogress = new stdClass();
		$this->retreive_sync = FALSE;
		
		if(empty($cache)){
  			$this->retreive_sync = FALSE;
  			
			$this->start = microtime(true);
			
			// Chargement des informations de flux
			$this->loadFluxInfos();
			
			// Chargement des vocabulaires liés
			$this->loadVocabularies();
			
		}else{
			
			$this->date = $cache->date;
			$this->flux = $cache->flux;
			$this->vocabs = $cache->vocabs;
			$this->vocab = $cache->vocab;
			$this->termCorresp = $cache->termCorresp;
			$this->done = $cache->done;
			$this->onprogress = $cache->onprogress;
  			$this->retreive_sync = TRUE;
	  		$this->start = microtime(true);
		}
  }
  
  /**
   *	get soap
   */
  public function soap(){
  	return $soap;
  }
  
  /**
   * Execute la synchronisation entre Drupal & Tourinsoft. 
   *
   * @param datetime $date Date of last synchronisation
   */
  public function sync($date = ""){
		// on met en cache les données pour éviter de les recharger
		// dans le cas où on est obliger de faire plusieurs passes pour synchroniser les données
		$this->setCache();
  	
  	$this->suspend = FALSE;
  	
  	module_load_include('inc', 'node', 'node.pages');
  	//$date = strtotime(substr("2010-12-01T01:15:17.0000000+01:00", 0, 10).' '.substr("2010-12-01T01:15:17.0000000+01:00", 11, 8));
		if(empty($date)){
			$this->date = variable_get("flux_last_sync", time());
		}else{
			$this->date = $date;
		}
  	
  	// Parcours des flux
  	$ctypes = $this->getNodeTypes();

  	foreach($this->flux as $fl){
	  	if(!$this->suspend){
	  		/*if($this->checkTime($fl, 'checkContentType', $fl->idmodule)){
		  		$this->checkContentType($ctypes, $fl);
		  	}*/
		  	drupal_set_message('Traitement du flux '.$fl->title);
	  		$this->majFlux($fl);
	  	}else{
	  		break;
	  	}
  	}
  	
  	// On est arrivé au bout, on peut vider !
  	if(!$this->suspend){
	  	variable_set("flux_sync_data_cache", "");
			variable_set("flux_last_sync", $this->date);
  	}
  }
  /**
   * Vérifie que le temps d'exécution n'est pas dépassé. 
   *
   * @param array $ctypes
   * @param array $flux
   */
  public function checkTime($flux, $action, $value){
  	if($this->suspend){
  		return false;
  	}
  	// Vérifie si on ne récupère pas une synchro en cours
  	if($this->retreive_sync){
  		// On vient d'une synchro interrompue  		
  		// Test si l'action a déjà été faite
  		if(isset($this->done->{$flux->idmodule}) && isset($this->done->{$flux->idmodule}->{$action}) && in_array($value, $this->done->{$flux->idmodule}->{$action})){
  			return false; // Action déjà faite, on passe à la suivante
  		}else{
  			// On place l'ancienne action au statut fait
  			if(isset($this->onprogress->flux)){
  				if(!isset($this->done->{$this->onprogress->flux})){
		  			$this->done->{$this->onprogress->flux} = new stdClass();
		  		}
	  			$this->done->{$this->onprogress->flux}->{$this->onprogress->action}[] = $this->onprogress->value;
	  		}
  			// L'action à réaliser est marquée en cours
  			$this->onprogress->flux = $flux->idmodule;
  			$this->onprogress->action = $action;
  			$this->onprogress->value = $value;
  		}
  	}
  	
  	// Vérifie que l'on ne dépasse pas le temps
  	$end = microtime(true);
  	if($end-$this->start > 60){ // 150 secondes = 2,5 minutes
  		
		$this->setCache();
			
  		$this->suspend = TRUE;

  		return false;
  	}else{
  		return true;
  	}
  }
  
  /**
   *	Create cache
   */
  public function setCache(){
		$this->cache->date = $this->date;
		$this->cache->flux = $this->flux;
		$this->cache->vocabs = $this->vocabs;
		$this->cache->vocab = $this->vocab;
		$this->cache->termCorresp = $this->termCorresp;
		$this->cache->onprogress = $this->onprogress;
		$this->cache->done = $this->done;
	
		variable_set("flux_sync_data_cache", $this->cache);
  }
  
  /**
   * Vérifie que le flux dispose d'un type de contenu. 
   *
   * @param array $ctypes
   * @param array $flux
   */
  public function checkContentType($ctypes, $flux){
  	if(!in_array('flux_'.strtolower(trim($flux->identifiant)), $ctypes)){
  		if($this->checkTime($flux, 'createcontenttype', $ctypes)){
  			$this->createContentType($flux);
  		}
  	}
  }
  
  /**
   * Récupère les ContentTypes de Flux. 
   *
   * @return array $node_types
   */
  public function getNodeTypes(){
  	// Sélection de tous les CT [Bordereau]
  	// Les CT [Bordereau] sont des CT dont le nom est flux_*
  	$node_types = array();
  	$node_types_all = node_get_types('names');
  	foreach($node_types_all as $node_type=>$name){
  		if(preg_match('/^flux_/', $node_type)){
  			$node_types[] = $node_type;
  		}
  	}
  	return $node_types;
  }
  
  /**
   * Récupère la liste des flux
   *
   * @return stdClass flux {nid, idmodule, identifiant}
   */
  public function loadFluxInfos(){
  	$this->flux = new stdClass();
  	$query = db_query("SELECT ctf.nid as nid, field_flux_idmodule_value as idmodule, field_flux_identifiant_value as identifiant, n.title as title, ctf.field_default_img_fid as fid FROM {content_type_flux} ctf INNER JOIN {node} n ON n.vid=ctf.vid WHERE n.status=1");
  	
  	while($result = db_fetch_object($query)){
  		$this->flux->{$result->nid} = $result;
  	}
  	
  }
  
  /**
   * Récupère les vocabulaires liés au flux
   *
   */
  public function loadVocabularies(){
  	/* Récupération du vocabulaire et des termes pour la recherche 
  	 *
  	 * Vocabulaire = Bordereau
  	 * Terme niveau 1 = flux
 		 * 	Terme niveau 2 = nom champ
 		 *		Terme niveau 3 = valeurs (term name: libelle, description: code, weight: ordre)
 		 */
 		
 		$vocabularies = $this->getDrupalVocabularies();
 		
 		// Parcours des flux et stockage des vocabulaires et/ou création
 		foreach($this->flux as $flux){
 			if(isset($vocabularies['Tourinsoft_'.$flux->identifiant])){
 				$vocabs[$flux->identifiant] = $vocabularies['Tourinsoft_'.$flux->identifiant];
 			}else{
 				$vocabulary = array(
			    'name' => 'Tourinsoft_'.$flux->identifiant,
			    'multiple' => 1,
			    'required' => 0,
			    'hierarchy' => 1,
			    'relations' => 0,
			    'module' => 'flux',
			    'weight' => -10,
			    'nodes' => array('flux_'.strtolower($flux->identifiant) => 1),
			  );
			  taxonomy_save_vocabulary($vocabulary);
			  // Récupération de nouveau des vocabulaires
			  $vocabularies = $this->getDrupalVocabularies();
			  // Ajout du nouveau vocabulaire
			  if(isset($vocabularies['Tourinsoft_'.$flux->identifiant])){
	 				$vocabs[$flux->identifiant] = $vocabularies['Tourinsoft_'.$flux->identifiant];
	 			}
 			}
 			
 			// Récupération des termes
 			$tree = $this->get_taxonomy_get_nested_tree((int) $vocabs[$flux->identifiant]['vid']);

			// Vérification si le term existe
			$term = $this->isTermExist($flux->title, $tree);
			if(!$term){
				// Création s'il n'existe pas
				$term = array(
			    'vid' => $vocabs[$flux->identifiant]['vid'], // Voacabulary ID
			    'name' => $flux->title, // Term Name
			  );

  			taxonomy_save_term($term);
			}
			$vocabs[$flux->identifiant]['terms'][$flux->title] = $term;
 		}

  	$this->vocabs = $vocabs;
  }
    
  /**
   * Parcours des vocabulaires et stockage dans un tableau pour traitement
   *
   * @param array $vocabularies
   */
  public function getDrupalVocabularies(){
  	// Parcours des vocabulaires et stockage dans un tableau pour traitement
 		$vocabularies = taxonomy_get_vocabularies();
 		foreach($vocabularies as $vocab){
 			// Stock les vocabulaires déjà existant
			$vocabulariesNames[$vocab->name] = array("vid"=>$vocab->vid, "name"=>$vocab->name);
 		}
 		return $vocabulariesNames;
  }
  
  /**
   * Met à jour le contenu Tourinsoft à partir du flux
   *
   * @param stdClass Flux
   */
  public function majFlux($flux){
  	$this->vocab = $this->vocabs[$flux->identifiant]['terms'][$flux->title];
  	// Récupération des données  de champ de recherche
  	$this->getFieldsSearch($flux);
   	// Récupération des données mises à jour dans Tourinsoft
  	$datas = $this->getListingDiff($flux);
  }
  
  /**
   * Webservice Tourinsoft : getFieldsSearch
   *
   * param stdClass fluxInfos
   */
  public function getFieldsSearch($fluxInfos){
  	
  	$resultset = $this->soap->call('getFieldsSearch', array('idModule'=>$fluxInfos->idmodule));
  	
  	$termParent = $this->vocabs[$fluxInfos->identifiant]['terms'][$fluxInfos->title];
  	
  	if($resultset){
		// Clear du dataset pour ne récupérer que les données
		$dataset = $this->clearResult($resultset);
		
		foreach($dataset as $data){
  		// Seuls les éléments de type entre 7 et 19 inclus sont de type liste
  		if($data['TYPE'] >= 7 && $data['TYPE'] <= 19){
  			if($this->checkTime($fluxInfos, 'fieldsSearch', $data['FORMFIELD_ID'])){
	  			// Si pas de terme de niveau 2 : création (nom du champ)
	  			$name = trim(utf8_encode($data['NAME']));
					if((!isset($termParent['children']) || !isset($termParent['children'][$name])) && !empty($name)){
						$term = array(
					    'vid' => $this->vocabs[$fluxInfos->identifiant]['vid'], // Voacabulary ID
					    'name' => $name, // Term Name
					    'parent' => array($termParent['tid'])
					  );
					  		  
		  			taxonomy_save_term($term);
		  			
						// Il faut récupérer le tid pour pouvoir l'attribuer ensuite a ses enfants
		  			$term['tid'] = $this->getTid($this->vocabs[$fluxInfos->identifiant]['vid'], trim(utf8_encode($name)), $termParent['tid']);
	
		  			$niveau2 = $term;
		  			
		  			$this->vocabs[$fluxInfos->identifiant]['terms'][$fluxInfos->title]['children'][$name] = $niveau2;
					}else{
						$niveau2 = $termParent['children'][$name];
					}	
					// Récupération des valeurs du champ
					$elements = $this->getListElements($fluxInfos, $data['FORMFIELD_ID'], $data['FORMFIELD_PARENT']);
					
					if(!isset($niveau2['children'])){
	  				$niveau3 = array();
	  			}else{
	  				$niveau3 = $niveau2['children'];
	  			}
	  			
					// Parcours des valeurs
					
					if(!empty($elements) && (is_array($elements) || is_object($elements))){
	  				foreach($elements as $element){
	  					$libelle = trim(utf8_encode($element['LIBELLE']));
	  					// Si la valeur existe déjà dans les termes de niveau 3, vérifie s'il faut modifier le libellé.
	  					if($value = $this->isTermExistByDesc($element['CODE'], $niveau3)){
	  						if($value['name'] != $libelle || $value['weight'] != $element['ORDRE']){
	  							$value['name'] = $libelle;
	  							$value['weight'] = $element['ORDRE'];
	  							
	  							taxonomy_save_term($value);
	  						}
	  					}elseif(!empty($libelle)){
	  					// S'il n'existe pas, on le créée
	  					// Terme niveau 3 = valeurs (term name: libelle, description: code, weight: ordre)
	  						$value = array(
							    'vid' => $this->vocabs[$fluxInfos->identifiant]['vid'], // Voacabulary ID
							    'name' => $libelle, // Term Name
							    'description' => $element['CODE'],
							    'parent' => array($niveau2['tid']),
							    'weight' => $element['ORDRE']
							  );
							  
	  						taxonomy_save_term($value);
	  						
	  						$value['tid'] = $this->getTid($this->vocabs[$fluxInfos->identifiant]['vid'], $libelle, $niveau2['tid']);
	  					}
	  					
	  					if($value){
		  					$this->vocabs[$fluxInfos->identifiant]['terms'][$fluxInfos->title]['children'][$name]['children'][$value['name']] = $value;
		  				}
	  				}	
	  			}  					
	  		}else{
	  			break;
	  		}
	  	}
  	}
  	}//Fin if resultset
  }
  
  /**
   * Webservice Tourinsoft : getTid
   *
   * param int vid
   * param string name
   * param int parent
   *
   * @return int tid
   */
  public function getTid($vid, $name, $parent){
  	$query = db_query("SELECT DISTINCT td.tid FROM {term_data} td INNER JOIN {term_hierarchy} th ON th.tid=td.tid WHERE td.vid=%d AND td.name='%s' AND th.parent = %d", array($vid, $name, $parent));
		if($result = db_fetch_object($query)){
			return $result->tid;
		}
		return "";
  }
  
  /**
   * Webservice Tourinsoft : getListingDiff
   *
   * param stdClass fluxInfos
   */
  public function getListingDiff($fluxInfos){
  	
  		$fieldsConf = flux_fieldsmapping($fluxInfos->identifiant);
  	
  	
   		$resultset = $this->soap->call('getListingDiff', array('idModule'=>$fluxInfos->idmodule, 'date'=>$this->date));
  	
  		$dataset=FALSE;
  		if($resultset){
			// Clear du dataset pour ne récupérer que les données
			$dataset = $this->clearResult($resultset);
		}
		$it = 0;
		if(is_array($dataset) && count($dataset)>0){
			// Liste les fiches a mettre à jour
			foreach($dataset as $dataList){
				
				if($it<1 && $this->checkTime($fluxInfos, 'getListingDiff', $data['ID'])){
				
					$datecrea = strtotime(substr($dataList['DATECREA'], 0, 10).' '.substr($dataList['DATECREA'], 11, 8));
					$datemaj = strtotime(substr($dataList['DATEMAJ'], 0, 10).' '.substr($dataList['DATEMAJ'], 11, 8));
					
					if($datecrea > $this->date || $datemaj > $this->date){
						// Récupère le détail de la fiche a mettre à jour
		 				$data = $this->getDetail($fluxInfos, $dataList);
		  				
			  			// Vérifie l'existence d'un node identique (éviter les doublons)
			  			$nid = $this->nodeExists($data['ID']);
			  			if(!$nid){ // Création uniquement si la fiche n'existe pas deja dans drupal
			  				$this->createData($data, $fluxInfos, $fieldsConf);
			  			}elseif($datemaj > $this->date){
			  				$this->updateData($data, $nid, $fieldsConf);
			  			}
			  		}
			  		
					$it++;
				}else{
					break;
				}
			}
		}
		
		
		watchdog('flux', 'Flux '.$fluxInfos->identifiant.' : Traitement de '.$it.' resultats');
  }
  
  /**
   * Webservice Tourinsoft : getDetail
   *
   * @param stdClass fluxInfos
   * @param array dataList
   * @return array data
   */
  public function getDetail($fluxInfos, $dataList){
   	$resultset = $this->soap->call('getDetail', array('idModule'=>$fluxInfos->idmodule, 'idOffre'=>$dataList['ID'], 'OBJETTOUR_CODE'=>strtoupper($fluxInfos->identifiant)));
  	$dataset = $this->clearResult($resultset);
  	return $dataset;
  }
  
  /**
   * Webservice Tourinsoft : getListElements
   *
   * @param stdClass fluxInfos
   * @param string formfield_id
   * @param string valeur_parent
   * @return array data
   */
  public function getListElements($fluxInfos, $formfield_id, $valeur_parent = ""){
  	
   	$resultset = $this->soap->call('getListElements', array('idModule'=>$fluxInfos->idmodule, 'FORMFIELD_ID'=>$formfield_id, 'VALEUR_PARENT'=>$valeur_parent));
   	if(isset($resultset['faultcode'])){
   		return false;
   	}
  	$dataset = $this->clearResult($resultset);
  	// Si le tableau contient la clé CODE au premier niveau, il faut rajouter une profondeur
  	if(isset($dataset['CODE'])){
	  	$dataset = array($dataset);
	  }
	  
  	return $dataset;
  }
  
  /**
   * Clear resultset to return only dataset
   *
   * @param array $result
   * @return array $dataset
   */
  public function clearResult($result){
  	$result = reset($result);
  	$dataset = $result['diffgram'];
  	if(is_array($dataset) || is_object($dataset)){
  		$dataset = reset($dataset);
  	}
  	if(is_array($dataset) || is_object($dataset)){
  		$dataset = reset($dataset);
  	}
  	return $dataset	; 
  }
  
  /**
   * Load Content Type fields of flux
   *
   * @param array $data
   * @return array $dataFields
   */
  /*public function loadDataFields($data){
  
  		$saved_infos = flux_fieldsmapping($data['OBJETTOUR_CODE']);
  
		module_load_include('inc', 'content', 'includes/content.crud');
		foreach($data as $name=>$value){
			
			$fieldInstanceInfo = content_field_instance_read(array('type_name'=>"flux_" . strtolower($data['OBJETTOUR_CODE']), 'field_name'=>"field_fl_" . strtolower($name)));
			if(!empty($fieldInstanceInfo)){
				$dataFields[$name] = $fieldInstanceInfo;
			}
		}
	
  	return $dataFields;
  }*/
  
  /**
   * Create node Data in Content Type
   *
   * @param array $data
   * @param stdClass $fluxInfos
   * @return boolean
   */
  public function createData($data, $fluxInfos, $fieldsConf){
  	
  	$nb = db_result(db_query("SELECT count(*) FROM {node_type} WHERE type='%s'", 'flux_' . strtolower($data['OBJETTOUR_CODE'])));
  	if(!$nb || $nb<=0){
  		drupal_set_message('Le type de contenu "'.'flux_' . strtolower($data['OBJETTOUR_CODE']).'" n\'existe pas, le flux ne peut être importé.', 'error');
  		return FALSE;
  	}
  	
  	if(!$fluxInfos || !isset($fluxInfos->nid)){
  		drupal_set_message('Un problème a été rencontré lors de la mise à jour des données.', 'error');
  		return FALSE;
  	}
  	
  	$node = new stdClass();
  	$node->type = 'flux_' . strtolower($data['OBJETTOUR_CODE']);
  	$node->language = '';
    $node->uid = '1';
    $node->name = 'admin';
    $node->status = '1';
    $node->created = time();
    $node->changed = $node->created; 
    $node->comment = '0';
    $node->promote = '1';
    $node->moderate = '0';
    $node->sticky = '0';
    $node->tnid = '0';
    $node->translate = '0';
    $node->revision_uid = $node->uid;
    $node->field_fl_nid_tx[0]['value'] = $fluxInfos->nid;
	$node->field_fl_id_bordereau_tx[0]['value'] = $fluxInfos->identifiant;
	$node->field_fl_id_module_tx[0]['value'] = $fluxInfos->idmodule;
	
	if(module_exists('domain')){
		$node->domains = array('-1' => -1);
		$node->domain_site = TRUE;
	}
	
	$fields = array();

	$success=TRUE;


	//Pour traiter les champs paramétrés, on prend la conf DANS L'ORDRE OU ELLE EST DONNEE (issu de flux_fieldsmapping)

	$ws_field_names = array_keys($fieldsConf);
	$ws_fields = array_keys($data);
	
	for($i=0; $i<count($ws_field_names) && $success; $i++){
		
		$prevName = $ws_field_names[$i];
		$name = substr($prevName, 0, 21);
		$value = $data[$prevName];
		
		if(intval($fieldsConf[$prevName]->required)===1){
			if(!in_array($prevName, $ws_fields)){
				watchdog($prevName.'N\'est pas dans la liste des champs du flux "'.$fluxInfos->identifiant.'".');
			}
		}
		
		//Si le champ est requis et vide, alors, on arrête tout
		if(strlen(trim(utf8_encode($value)))<=0 && intval($fieldsConf[$prevName]->required)===1){
			$success=FALSE;
			watchdog('flux', 'Le champ requis "'.$prevName.'" est vide : "'.$data[$prevName].'". Bordereau : '.$fluxInfos->identifiant, array(), WATCHDOG_ERROR);
			
		}else{
			$function = $fieldsConf[$prevName]->fieldfunction.'_fluxfieldvalue';
	
			if(function_exists($function)){
				
				$defaultVals = array();
				
				//Image par défaut
				if($fluxInfos->fid!=NULL){
					$defaultVals['fid'] = $fluxInfos->fid;
				}
				
				$function($node, $fieldsConf[$prevName]->cckfieldname, $value, $defaultVals);
				
			}else{
				
				drupal_set_message('La fonction "'.$function.'()" n\'existe pas.', 'error');
			}
	  			
	  		if(isset($this->vocab['children'][$name])){ // Si le champ existe dans la taxonomy du type de contenu
	  			$terms = $this->vocab['children'][$name]['children'];
	  			// Sélection des termes correspondant aux valeurs du champ
	  			$values = explode("#", $value);
	  			foreach($values as $val){
	  				$val = trim(utf8_encode($val));
	  				if(isset($terms[$val]) && !in_array($terms[$val]['tid'], $fields)){
	  					$fields[] = $terms[$val]['tid'];
	  				}
	  			}
	  		}
		}
		
	}


	foreach(module_implements('flux_alterdata') as $module){
		$func = $module.'_flux_alterdata'; 
		$func($node);
	}

  	/*foreach($data as $name=>$value){ // Parcours des données reçues
  		$success=TRUE;
  		
  		$prevName = $name;
  		
  		$name = substr($name, 0, 21); // La taille du nom de champ est limitée par cck
		
  		if(isset($fieldsConf[$prevName])){ // Si le champ existe dans le type de contenu
  			
  			$function = $fieldsConf[$prevName]->fieldfunction.'_fluxfieldvalue';
			
  			if(function_exists($function)){
  				
  				$success = $function($node, $fieldsConf[$prevName]->cckfieldname, $value);
  				
  			}else{
  				drupal_set_message('La fonction "'.$function.'()" n\'existe pas.', 'error');
  			}
  			
  		}
  		if(isset($this->vocab['children'][$name])){ // Si le champ existe dans la taxonomy du type de contenu
  			$terms = $this->vocab['children'][$name]['children'];
  			// Sélection des termes correspondant aux valeurs du champ
  			$values = explode("#", $value);
  			foreach($values as $val){
  				$val = trim(utf8_encode($val));
  				if(isset($terms[$val]) && !in_array($terms[$val]['tid'], $fields)){
  					$fields[] = $terms[$val]['tid'];
  				}
  			}
  		}
  		
  		if(!$success)
  			break;
  	}*/
  	
  	//Si aucun champ n'a bloqué le process
  	if($success){
  		// ajout du term principal pour connaitre le flux grace a la taxo
	  	$fields[] = $this->vocab['tid'];
	  	$node->taxonomy[$this->vocab['vid']] = $fields;
	
	  	$node = node_submit($node);
		node_save($node);
		
		return TRUE;
  	}
  	
  	return FALSE;
  }
  
  /**
   * Update node Data in Content Type
   *
   * @param array $data
   * @param int $nid
   * @return boolean
   */
  public function updateData($data, $nid, $fieldsConf){
  	$node = node_load($nid);
  	
    $fields = array();
  	
  	$success=TRUE;
  	
  	$ws_field_names = array_keys($fieldsConf);
	$ws_fields = array_keys($data);
	
	for($i=0; $i<count($ws_field_names) && $success; $i++){
		
		$prevName = $ws_field_names[$i];
		$name = substr($prevName, 0, 21);
		$value = $data[$prevName];
		
		if(intval($fieldsConf[$prevName]->required)===1){
			if(!in_array($prevName, $ws_fields)){
				watchdog($prevName.'N\'est pas dans la liste des champs du flux "'.$fluxInfos->identifiant.'".');
			}
		}
		
		//Si le champ est requis et vide, alors, on arrête tout
		if(strlen(trim(utf8_encode($value)))<=0 && intval($fieldsConf[$prevName]->required)===1){
			$success=FALSE;
			watchdog('flux', 'Le champ requis "'.$prevName.'" est vide : "'.$data[$prevName].'". Bordereau : '.$fluxInfos->identifiant, array(), WATCHDOG_ERROR);
			
		}else{
			$function = $fieldsConf[$prevName]->fieldfunction.'_fluxfieldvalue';
	
			if(function_exists($function)){
				
				$function($node, $fieldsConf[$prevName]->cckfieldname, $value);
				
			}else{
				drupal_set_message('La fonction "'.$function.'()" n\'existe pas.', 'error');
			}
	  			
	  		if(isset($this->vocab['children'][$name])){ // Si le champ existe dans la taxonomy du type de contenu
	  			$terms = $this->vocab['children'][$name]['children'];
	  			// Sélection des termes correspondant aux valeurs du champ
	  			$values = explode("#", $value);
	  			foreach($values as $val){
	  				$val = trim(utf8_encode($val));
	  				if(isset($terms[$val]) && !in_array($terms[$val]['tid'], $fields)){
	  					$fields[] = $terms[$val]['tid'];
	  				}
	  			}
	  		}
		}
		
	}
  	if($success){
	  	$node->taxonomy[$this->vocab['vid']] = $fields;
	  	
	  	if($nid && !empty($nid)){
		  	$node = node_submit($node);
				node_save($node);
		}
		
	  	return TRUE;
	  	
	}else{
	
		return FALSE;
	
	}
  }
   
  /**
   * Function from http://api.drupal.org/api/drupal/modules--taxonomy--taxonomy.module/function/taxonomy_get_tree/6 to get real taxonomy tree
   *
   */
  function get_taxonomy_get_nested_tree($terms = array(), $max_depth = NULL, $parent = 0, $parents_index = array(), $depth = 0) {
	  if (is_int($terms)) {
	    $terms = taxonomy_get_tree($terms);
	  }
	  
	  foreach($terms as $term) {
	  	if(!is_array($term)){
	  		$term = get_object_vars($term);
	  	}
	  	$termCorresp[$term['tid']] = $term['name'];
	    foreach($term['parents'] as $term_parent) {
	      if ($term_parent == $parent) {
	        $return[$term['name']] = $term;
	      }
	      else {
	        $parents_index[$termCorresp[$term_parent]][$term['name']] = $term;
	      }
	    }
	  }
	  if(!empty($return)){
		  foreach($return as &$term) {
		    if (isset($parents_index[$term['name']]) && (is_null($max_depth) || $depth < $max_depth)) {
		      $term['children'] = $this->get_taxonomy_get_nested_tree($parents_index[$term['name']], $max_depth, $term['tid'], $parents_index, $depth + 1);
		    }
		  }
		}	  
	  return $return;
	}
	
  /**
   * Vérifie l'existence d'un term en fonction de son nom
   *
   * @param string $name
   * @param array $tree
   *
   * @return stdClass $term OR false if no term exist
   */
  function isTermExist($name, $tree){
  	if(empty($tree)){
  		return false;
  	}
  	foreach($tree as $term){
  		if($term['name'] == $name){
  			return $term;
  		}
  	}
  	return false;
  }
  
  
  /**
   * Vérifie l'existence d'un term en fonction de sa description
   *
   * @param string $name
   * @param array $tree
   *
   * @return stdClass $term OR false if no term exist
   */
  function isTermExistByDesc($description, $tree){
  	foreach($tree as $term){
  		if($term['description'] == $description){
  			return $term;
  		}
  	}
  	return false;
  }
  
  /**
   * Check if node already exist
   *
   * @param string $id
   * @return int $nid
   */
  public function nodeExists($id){
  	$query = db_query("SELECT nid FROM {content_field_flux_id} WHERE field_flux_id_value = '%s'", array($id));
  	if($result = db_fetch_object($query)){
  		return $result->nid;
  	}else
  	{
  		return false;
  	}
  }
  
  /**
   * Récupère les champs de tous les flux d'un bordereau. 
   *
   * @param array $flux
   * @return array $fields
   */
  public function getFieldsByFluxIdentifiant($identifiant){
  	$fields = array();
  	$fields_exist = array();
  	$query = db_query("SELECT ctf.field_flux_idmodule_value FROM {content_type_flux} ctf WHERE ctf.field_flux_identifiant_value = '%s'", array($identifiant));
  	while($result = db_fetch_object($query)){ // Pour chaque flux
  		// On récupère les champs d'un flux
	  	$resultset = $this->soap->call('getFieldsDetail', array('idModule'=>$result->field_flux_idmodule_value));
	  	$dataset = $this->clearResult($resultset);
	  	foreach($dataset as $cle=>$val){
	  		// On vérifie qu'il n'est pas déjà dans la liste des flux
	  		if(!in_array($val['DETAILFIELD_NAME'], $fields_exist)){
	  			$fields[] = $val;
	  			$fields_exist[] = $val['DETAILFIELD_NAME'];
	  		}
	  	}
	  }
	  return $fields;
  }
  
  

}
?>
